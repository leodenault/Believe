package believe.character

import believe.core.Updatable
import believe.react.Observable
import believe.react.ObservableValue
import dagger.Reusable
import javax.inject.Inject
import kotlin.math.max
import kotlin.math.min

@Reusable
internal class VulnerabilityStateMachine @Inject internal constructor(
    @InvulnerabilityLength private val invulnerabilityLength: Long,
    @AnimationFlashLength private val animationFlashLength: Long,
    @MaxFocus private val maxFocus: Float,
    @FocusRechargeTime focusRechargeTime: Long
) : Updatable {

    private val focusRechargeRate = maxFocus / focusRechargeTime
    private val animationInvisibleBucket = (invulnerabilityLength / animationFlashLength) % 2
    private val becomeInvulnerable: (Float) -> Unit = { damage ->
        isVulnerable = false
        isAnimationVisible = false
        remainingVulnerabilityTime = invulnerabilityLength
        vulnerabilityUpdater = updateVulnerability
        inflictDamageInternal = DAMAGE_NOTHING

        val currentFocus = internalFocus.get()
        internalFocus.setValue(max(0f, currentFocus - damage))
    }
    private val updateVulnerability = Updatable updateVulnerability@{ delta ->
        remainingVulnerabilityTime -= delta
        if (remainingVulnerabilityTime <= 0) {
            isVulnerable = true
            isAnimationVisible = true
            vulnerabilityUpdater = UPDATE_NOTHING
            inflictDamageInternal = becomeInvulnerable
            return@updateVulnerability
        }

        isAnimationVisible = currentBucket() != animationInvisibleBucket
    }
    private val internalFocus = ObservableValue.of(maxFocus)

    private var remainingVulnerabilityTime = 0L
    private var vulnerabilityUpdater: Updatable = UPDATE_NOTHING
    private var inflictDamageInternal: (Float) -> Unit = becomeInvulnerable

    val focus: Observable<Float> = internalFocus

    var isVulnerable = true
        private set
    var isAnimationVisible = true
        private set

    fun inflictDamage(damage: Float) = inflictDamageInternal(damage)

    override fun update(delta: Long) {
        val currentFocus = internalFocus.get()
        internalFocus.setValue(min(maxFocus, currentFocus + delta * focusRechargeRate))
        vulnerabilityUpdater.update(delta)
    }

    private fun currentBucket(): Long {
        val horizontalOffset =
            animationFlashLength - (invulnerabilityLength % animationFlashLength) - 1
        val bucket = (remainingVulnerabilityTime + horizontalOffset) / animationFlashLength
        return bucket % 2
    }

    companion object {
        private val DAMAGE_NOTHING: (Float) -> Unit = { }
        private val UPDATE_NOTHING = Updatable { }
    }
}
