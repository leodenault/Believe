#####################
# Private constants #
#####################
_MAX_CLASSPATH_LINE_LENGTH = 70

# Selection of full or short path when copying files.
_FULL_PATH = 0
_SHORT_PATH = 1

#####################

def _normalize_classpath(classpath):
    """
    Takes a classpath string and chops it up into lines of length _MAX_CLASSPATH_LINE_LENGTH.
    """
    classpath_length = len(classpath)
    if classpath_length <= _MAX_CLASSPATH_LINE_LENGTH:
        return classpath

    lines = [classpath[0:_MAX_CLASSPATH_LINE_LENGTH]]
    for i in range(_MAX_CLASSPATH_LINE_LENGTH, classpath_length, _MAX_CLASSPATH_LINE_LENGTH - 1):
        lines.append(classpath[i:i + _MAX_CLASSPATH_LINE_LENGTH - 1])

    return "\n ".join(lines)

def _make_dir_and_copy_file(file, dest_dir, dest_file_name = None):
    """
    Generates commands for making a directory for a file and copying the file into the directory.
    """
    dest_name = dest_file_name if dest_file_name else file.basename
    out_file = dest_dir + "/" + dest_name
    cmd = "mkdir -p " + dest_dir + "\n"
    cmd += "cp " + file.path + " " + out_file

    if file.path.startswith("bazel-out"):
        cmd += "\nchmod 755 " + out_file

    return cmd

def _make_dirs_and_copy_files(files, dest_dir):
    """
    Generates commands for making directories for a set of files and copying the files into the
    directories.
    """
    commands = []
    for file in files:
        if file.dirname.startswith("bazel-out"):
            # Make sure to skip the Bazel output file path prefix if it exists.
            last_slash_index = file.short_path.rfind("/")
            if last_slash_index < 0:
                file_dir_name = ""
            else:
                file_dir_name = "/" + file.short_path[:last_slash_index]

            # Remove the java/ file path prefix if it exists.
            file_dir_name = file_dir_name.replace("java/", "")
        else:
            file_dir_name = "/" + file.dirname
        commands.append(_make_dir_and_copy_file(file, dest_dir + file_dir_name))
    return "\n".join(commands)

def _generate_run_script(basename, jar_name):
    return "\n".join([
        "#!/bin/bash",
        "function create_debug_flag() {",
        "  if [[ $# -eq 1 ]]; then",
        "    JVM_DEBUG_PORT=\"$1\"",
        "  else",
        "    JVM_DEBUG_PORT=\"${DEFAULT_JVM_DEBUG_PORT:-5005}\"",
        "  fi",
        "  JVM_DEBUG_SUSPEND=${DEFAULT_JVM_DEBUG_SUSPEND:-\"y\"}",
        "  echo \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=${JVM_DEBUG_SUSPEND},address=${JVM_DEBUG_PORT}\"",
        "}",
        "function process_java_arg() {",
        "  local val=$1",
        "  case \"$1\" in",
        "    --debug) var=$(create_debug_flag) ;;",
        "    --debug=*) var=$(create_debug_flag \"${1#--debug=}\") ;;",
        "    *) ;;",
        "  esac",
        "  echo \"$var\"",
        "}",
        "ARGS=()",
        "JAVA_ARGS=()",
        "for ARG in \"$@\"; do",
        "  JAVA_ARG=$(process_java_arg \"$ARG\")",
        "  if [[ -n $JAVA_ARG ]]; then",
        "    JAVA_ARGS+=( \"$JAVA_ARG\" )",
        "  else",
        "    ARGS+=( \"$ARG\" )",
        "  fi",
        "done",
        "cd " + basename + ";java \"${JAVA_ARGS[@]}\" -jar " + jar_name + " \"${ARGS[@]}\"",
    ])

def _believe_binary_impl(ctx):
    out_dir = ctx.outputs.out_dir
    build_dir = out_dir.path + ".build"
    jar_name = ctx.attr.jar_name if ctx.attr.jar_name else ctx.attr.name + "_app.jar"
    jar_path = out_dir.path + "/" + jar_name
    manifest_temp = ctx.outputs._manifest_temp

    generated_libs = []  # Libraries generated by Believe source code.
    third_party_libs = []  # Libraries generated by third party dependencies (java_import).
    internal_data_files = []  # Data files that should reside within the final jar file.

    # Split up the jar files into third party libraries, generated libraries, and internal data
    # files.
    for dep in ctx.attr.runtime_deps:
        for file in dep.data_runfiles.files:
            if file.is_source:
                third_party_libs.append(file)
            elif file.path.endswith("jar"):
                generated_libs.append(file)
            else:
                internal_data_files.append(file)

    third_party_lib_paths = [file.path for file in third_party_libs]

    # Gather the data files which will reside outside of the final jar file.
    data_files = []
    openal_files = []
    for dep in ctx.attr.data:
        for file in dep.files:
            if "openal" in file.basename.lower():
                openal_files.append(file)
            else:
                data_files.append(file)
    data_file_paths = [file.short_path for file in data_files]

    # Gather the resource files which will be put into the final jar file.
    resource_files = [file for dep in ctx.attr.resources for file in dep.files]

    # Set up the manifest file contents.
    manifest_main_class = "Main-Class: " + ctx.attr.main_class
    manifest_classpath = "Class-Path: " + " ".join(data_file_paths + third_party_lib_paths)
    manifest_content = manifest_main_class + "\n" + _normalize_classpath(manifest_classpath) + "\n"

    ctx.file_action(
        output = manifest_temp,
        content = manifest_content,
        executable = False,
    )

    cmd = "mkdir " + build_dir + "\n"

    # Unzip the jar contents of the generated libraries and zip them up in the final jar file.
    cmd += "".join([
        "unzip -q " + jar.path + " -d " + build_dir + " -x META-INF/*\n"
        for jar in generated_libs
    ])

    # Then copy the resources and the manifest in the build directory to include them in the jar,
    # too.
    cmd += _make_dirs_and_copy_files(resource_files, build_dir) + "\n"
    cmd += _make_dirs_and_copy_files(internal_data_files, build_dir) + "\n"
    cmd += _make_dir_and_copy_file(manifest_temp, build_dir + "/META-INF", "MANIFEST.MF") + "\n"
    cmd += "mkdir " + out_dir.path + "\n"
    cmd += "jar -cfM " + jar_path + " -C " + build_dir + "/ ." + "\n"

    # Copy the data to the output directory.
    cmd += _make_dirs_and_copy_files(data_files, out_dir.path) + "\n"
    cmd += _make_dirs_and_copy_files(third_party_libs, out_dir.path) + "\n"
    cmd += "\n".join([_make_dir_and_copy_file(file, out_dir.path) for file in openal_files])

    ctx.actions.run_shell(
        inputs = (
            generated_libs +
            third_party_libs +
            internal_data_files +
            resource_files +
            data_files +
            openal_files +
            [manifest_temp]
        ),
        outputs = [out_dir],
        command = cmd,
        use_default_shell_env = True,
    )

    # This is needed so that the rule can be launch with 'bazel run'.
    ctx.actions.write(
        output = ctx.outputs.executable,
        content = _generate_run_script(out_dir.basename, jar_name),
        is_executable = True,
    )

    return [DefaultInfo(
        runfiles = ctx.runfiles(files = [out_dir]),
        files = depset([out_dir]),
    )]

def _zip_impl(ctx):
    zip_file = ctx.outputs.zip_file
    files_to_zip = [file for dep in ctx.attr.deps for file in dep.files]
    file_string = ""
    single_dir = False
    if len(files_to_zip) == 1 and files_to_zip[0].extension == "":
        # If there's only one file and it's a directory, then only include its contents.
        file_string += "*"
        single_dir = True
    else:
        # Include all of the listed files in all dependencies.
        file_string += " ".join([file.path for file in files_to_zip])

    cmd = ""
    if single_dir:
        cmd += "current_dir=$(pwd)\n"
        cmd += "cd " + files_to_zip[0].path + "\n"
    cmd += "zip -qr " + ("$current_dir/" if single_dir else "") + zip_file.path + " " + file_string

    ctx.actions.run_shell(
        inputs = files_to_zip,
        outputs = [zip_file],
        command = cmd,
        use_default_shell_env = True,
    )

def _pkg_all_impl(ctx):
    out_dir = ctx.outputs.out_dir
    files = [file for dep in ctx.attr.deps for file in dep.files]
    cmd = "mkdir " + out_dir.path + "\n"
    cmd += "\n".join(["cp " + file.path + " " + out_dir.path for file in files])
    ctx.actions.run_shell(
        inputs = files,
        outputs = [out_dir],
        command = cmd,
        use_default_shell_env = True,
    )

def java_junit5_test(name = "", srcs = [], test_class = "", deps = []):
    # In the case there's a single source we can automatically determine the test class.
    if len(srcs) == 1 and test_class == "":
        package = native.package_name()
        package_start_index = package.find("/") + 1

        # Remove java or javatests top-level directory reference from package path.
        package = package[package_start_index:]
        package = package.replace("/", ".")

        test_class = package + "." + srcs[0]
        test_class = test_class[:-len(".java")]

    native.java_test(
        name = name,
        srcs = srcs,
        args = [
            "--select-class",
            test_class,
        ],
        main_class = "org.junit.platform.console.ConsoleLauncher",
        use_testrunner = False,
        deps = deps + ["//third_party/junit"],
    )

def textproto(name = "", srcs = [], java_outer_class_name = "", proto_message = "", deps = []):
    """Defines a set of protos written as textprotos and converts them to binary at build time.
    """

    outs = [(val[:val.rfind(".")] + ".pb") for val in srcs]
    proto_class = java_outer_class_name + "\\$$" + proto_message
    src_args = " ".join(["$(location " + src + ")" for src in srcs])
    binary_name = name + "_proto_file_serializer"

    native.java_binary(
        name = binary_name,
        main_class = "believe.tools.ProtoFileSerializer",
        runtime_deps = ["//java/believe/tools:proto_file_serializer"] + deps,
    )

    cmd = "$(location :{binary_name}) {proto_class} $(@D) {src_args}".format(
        binary_name = binary_name,
        proto_class = proto_class,
        src_args = src_args,
    )

    native.genrule(
        name = name,
        srcs = srcs,
        outs = outs,
        cmd = cmd,
        tools = [":" + binary_name],
    )

believe_binary = rule(
    _believe_binary_impl,
    attrs = {
        "data": attr.label_list(allow_files = True),
        "main_class": attr.string(mandatory = True),
        "resources": attr.label_list(allow_files = False),
        "runtime_deps": attr.label_list(allow_files = False),
        "jar_name": attr.string(mandatory = False),
    },
    outputs = {
        "out_dir": "%{name}_bin",
        "_manifest_temp": "MANIFEST_%{name}.MF",
    },
    executable = True,
)

pkg_zip = rule(
    _zip_impl,
    attrs = {
        "deps": attr.label_list(allow_files = True),
    },
    outputs = {
        "zip_file": "%{name}.zip",
    },
)

pkg_all = rule(
    _pkg_all_impl,
    attrs = {
        "deps": attr.label_list(allow_files = False),
    },
    outputs = {
        "out_dir": "%{name}_pkgs",
    },
)
